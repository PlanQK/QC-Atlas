/*******************************************************************************
 * Copyright (c) 2020 the qc-atlas contributors.
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/

package org.planqk.atlas.core.services;

import java.util.UUID;
import javax.transaction.Transactional;

import org.planqk.atlas.core.model.PatternRelation;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

/**
 * Service class for operations related to interacting and modifying {@link PatternRelation}s in the database.
 */
public interface PatternRelationService {

    /**
     * Creates a new database entry for a given {@link PatternRelation} and save it to the database.
     * <p>
     * The ID of the {@link PatternRelation} parameter should be null, since the ID will be generated by the database
     * when creating the entry. The validation for this is done by the Controller layer, which will reject {@link
     * PatternRelation}s with a given ID in its create path.
     * <p>
     * The {@link org.planqk.atlas.core.model.PatternRelationType} has to be set and can not be null. However, only the
     * ID of the type has to be set since the correct type object will be queried from the database. This way we can
     * check if the given type exists in the database without another checking step. If the {@link
     * org.planqk.atlas.core.model.PatternRelationType} with given ID doesn't exist a {@link
     * java.util.NoSuchElementException} is thrown.
     * <p>
     * The same approach is taken for the algorithm of the {@link PatternRelation}. All other properties of the {@link
     * org.planqk.atlas.core.model.Algorithm} in the {@link PatternRelation} parameter will be ignored, except the ID
     * which will also be used to query the {@link org.planqk.atlas.core.model.Algorithm} object from the database. This
     * way we will also check if the given {@link org.planqk.atlas.core.model.Algorithm} exists in the database without
     * another step checking for this. If either of the algorithms don't exist a {@link
     * java.util.NoSuchElementException} is thrown.
     *
     * @param patternRelation The {@link PatternRelation} object describing the relation between a source and a target
     *                        algorithm that should be saved to the database
     * @return The {@link PatternRelation} object that represents the saved status of the database
     */
    @Transactional
    PatternRelation create(PatternRelation patternRelation);

    /**
     * Find a database entry of a {@link PatternRelation} that is already saved in the database. This search is based on
     * the ID the database has given the {@link PatternRelation} object when it was created and first saved to the
     * database.
     * <p>
     * If there is no entry found in the database this method will throw a {@link java.util.NoSuchElementException}.
     *
     * @param patternRelationId The ID of the {@link PatternRelation} we want to find
     * @return The {@link PatternRelation} with the given ID
     */
    PatternRelation findById(UUID patternRelationId);

    /**
     * Retrieve multiple {@link PatternRelation} entries from the database.
     * <p>
     * The amount of entries is based on the given {@link Pageable} parameter. If the {@link Pageable} is unpaged a
     * {@link Page} with all entries is queried.
     *
     * @param pageable The page information, namely page size and page number, of the page we want to retrieve
     * @return The page of queried {@link PatternRelation} entries
     */
    Page<PatternRelation> findAll(Pageable pageable);

    /**
     * Update an existing {@link PatternRelation} database entry by saving the updated {@link PatternRelation} object to
     * the the database.
     * <p>
     * The ID of the {@link PatternRelation} parameter has to be set to the ID of the database entry we want to update.
     * The validation for this ID to be set is done by the Controller layer, which will reject {@link PatternRelation}s
     * without a given ID in its update path. This ID will be used to query the existing {@link PatternRelation} entry
     * we want to update. If no {@link PatternRelation} entry with the given ID is found this method will throw a {@link
     * java.util.NoSuchElementException}.
     * <p>
     * The {@link org.planqk.atlas.core.model.PatternRelationType} has to be set and can not be null. However, only the
     * ID of the type has to be set since the correct type object will be queried from the database in order to reduce
     * the error margin for user input. This way we can check if the given type exists in the database without another
     * checking step. If the {@link org.planqk.atlas.core.model.PatternRelationType} with given ID doesn't exist a
     * {@link java.util.NoSuchElementException} is thrown. In the update process the type will not be updated itself.
     *
     * @param patternRelation The {@link PatternRelation} we want to update with its updated properties
     * @return the updated {@link PatternRelation} object that represents the updated status of the database
     */
    @Transactional
    PatternRelation update(PatternRelation patternRelation);

    /**
     * Delete an existing {@link PatternRelation} entry from the database. This deletion is based on the ID the database
     * has given the {@link PatternRelation} when it was created and first saved to the database.
     * <p>
     * If no entry with the given ID is found this method will throw a {@link java.util.NoSuchElementException}.
     *
     * @param patternRelationId The ID of the {@link PatternRelation} we want to delete
     */
    @Transactional
    void delete(UUID patternRelationId);

    /**
     * Checks if a {@link org.planqk.atlas.core.model.Algorithm} is part of a {@link PatternRelation}. In order to
     * uniquely identify the {@link org.planqk.atlas.core.model.Algorithm} and the {@link PatternRelation} their IDs,
     * which are given as parameters to this method, will be used.
     * <p>
     * If there is no {@link PatternRelation} found with the ID given in the {@param patternRelationId} parameter or if
     * there is a {@link PatternRelation} found the algorithm doesn't match the ID given in the {@param algorithmId}
     * parameter a {@link java.util.NoSuchElementException} is thrown.
     *
     * @param algorithmId       The ID of the {@link org.planqk.atlas.core.model.Algorithm} we want to check
     * @param patternRelationId The ID of the {@link PatternRelation} we want to check
     */
    void checkIfAlgorithmIsInPatternRelation(UUID algorithmId, UUID patternRelationId);
}
